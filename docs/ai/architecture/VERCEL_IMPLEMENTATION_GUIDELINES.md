# Jeopardy App Architecture (React + Supabase on Vercel — Zero Vercel Functions)

**IMPORTANT NOTE:** The following documentation was generated by someone without detailed knowledge of this app.  Speculative and inaccurate assumptions should be expected --- the main value of the advice below is specifically regarding how to ensure we don't exceed the 125 Vercel query limit (i.e. by leveraging Supabase calls directly and minimizing Vercel calls as much as possible.)

**Blunt summary:** Host the React bundle on Vercel as a static site. All reads/writes and realtime are done **directly from the client to Supabase**. Do not proxy through Vercel serverless functions — that would instantly blow the free quota. If server-side logic is ever needed, put it in **Supabase Edge Functions**, not Vercel.

---

## Goals

* **Fast, real-time gameplay** (buzzers, lockouts, scores).
* **No Vercel function executions** (safe on free tier).
* **Authoritative state** enforced by Postgres (atomic writes).
* **Row-Level Security (RLS)** as the real guardrail.

---

## High-Level Design

```
[Vercel Hosting]   -> Serves static React app (Vite build)
[Browser Client]   -> supabase-js
[Supabase Project] -> Postgres + Realtime + Auth + Edge Functions (optional)
```

---

## Deployment Notes (Vercel)

1. **Environment Variables**

   * In Vercel Project → Settings → Environment Variables:

     * `VITE_SUPABASE_URL`
     * `VITE_SUPABASE_ANON_KEY`
   * Only keys prefixed with `VITE_` are exposed to the client bundle.
   * Do not include the **service_role** key — keep that server-side only.

2. **Supabase Auth Redirects**

   * Supabase Dashboard → Auth → URL Configuration:

     * **Site URL**: your production domain (`https://your-app.vercel.app` or custom domain).
     * **Redirect URLs / Allowed Origins**: include

       * `http://localhost:5173` (dev)
       * `https://*.vercel.app` (preview builds) if you want auth to work on previews
       * Production domain.
   * If you get “redirect URL not allowed” errors → check this config.

3. **Realtime**

   * Ensure Realtime is enabled for the tables you subscribe to.
   * Always **filter by room_id** (or equivalent) when subscribing to Postgres changes to avoid noisy streams.

4. **CORS**

   * Supabase endpoints already handle CORS — no Vercel tweaks needed.

5. **Preview Deployments**

   * Every branch = a new preview domain. If you want auth there, whitelist the wildcard domain in Supabase.

---

## Client Setup

### Supabase Initialization

```ts
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL!,
  import.meta.env.VITE_SUPABASE_ANON_KEY!,
  {
    auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true },
    realtime: { params: { eventsPerSecond: 20 } }
  }
);
```

### Auth

* Options:

  * **Anonymous sign-in + profile handle** (frictionless, fine for friends).
  * **Magic links or OAuth** (requires proper redirect URLs).
* Roles (host vs player) enforced by RLS, not client checks.

---

## Realtime Strategy

* **Presence channel**: ephemeral signals (who’s in the room, countdown ticks).
* **DB changes channel**: authoritative state (clue reveal, buzz winner, scores).

```ts
const presence = supabase.channel(`presence:room:${roomId}`, {
  config: { presence: { key: playerId } }
});

presence
  .on('presence', { event: 'sync' }, () => {
    const state = presence.presenceState();
    // track connected players
  })
  .on('broadcast', { event: 'ui' }, ({ payload }) => {
    // ephemeral UI signals
  })
  .subscribe();

const changes = supabase.channel(`db:room:${roomId}`)
  .on('postgres_changes', { event: '*', schema: 'public', table: 'clues_state', filter: `room_id=eq.${roomId}` }, payload => {
    // react to authoritative DB updates
  })
  .subscribe();
```

**Rule:**

* **Broadcast** for milliseconds-latency UI (countdowns, hover states).
* **DB changes** for persisted, authoritative transitions.

---

## Buzzers: Latency-Equalized, Host-Resolved (not “first message wins”)

* **Not** a race to reach the server. Each client computes a local **reaction time** from the unlock event; the **host** adjudicates after a short settle window and then commits the winner to the DB.
* Use Realtime **broadcast** for buzz submissions (low RTT, no DB writes per buzz). The **only** DB write is the final winner record.

```ts
// Client: when host broadcasts "unlock", start local timer; on press, submit reactionMs.
type BuzzPayload = {
  roomId: string;
  clueId: string;
  playerId: string;
  reactionMs: number;         // performance.now() - unlockReceivedAt
  clientSentAtMs: number;     // optional: local timestamp for audit
};

export async function submitBuzz(
  channel: ReturnType<typeof supabase.channel>,
  payload: BuzzPayload
) {
  await channel.send({
    type: 'broadcast',
    event: 'buzz',
    payload
  });
}
```

```ts
// Host: collect buzzes for a short window after first buzz, then pick the lowest reactionMs.
const SETTLE_MS = 250; // 200–300ms typical

type BuzzState = {
  firstReceivedAt: number | null;
  entries: BuzzPayload[];
  timer: number | null;
};

const buzzState: Record<string /*clueId*/, BuzzState> = {};

presenceChannel.on('broadcast', { event: 'buzz' }, async ({ payload }: { payload: BuzzPayload }) => {
  const key = payload.clueId;
  const now = performance.now();

  if (!buzzState[key]) buzzState[key] = { firstReceivedAt: null, entries: [], timer: null };
  const state = buzzState[key];

  state.entries.push(payload);

  if (!state.firstReceivedAt) {
    state.firstReceivedAt = now;
    state.timer = window.setTimeout(() => settleAndCommitWinner(payload.roomId, key), SETTLE_MS);
  }
});

async function settleAndCommitWinner(roomId: string, clueId: string) {
  const state = buzzState[clueId];
  if (!state) return;

  // Choose smallest reactionMs (optionally apply RTT adjustments if you track them).
  const winner = state.entries.reduce((min, e) => (e.reactionMs < min.reactionMs ? e : min));

  // Commit winner authoritatively to DB (single write).
  const { error } = await supabase
    .from('buzz_winners') // your table/view for the authoritative winner
    .insert({
      room_id: roomId,
      clue_id: clueId,
      player_id: winner.playerId,
      reaction_ms: winner.reactionMs
    });

  // Note: RLS should restrict this insert to the host only.

  // Cleanup
  if (state.timer) clearTimeout(state.timer);
  delete buzzState[clueId];
}
```

**Propagation:**
All clients learn the result from the **DB change feed** on the winner table (`postgres_changes`). The database remains the **source of truth** for the final outcome, but **latency fairness** comes from host adjudication of **client-reported reaction times**, not message arrival order.

---

## RLS Guidelines

* **Select policies**: Only room members can read rows for that room.
* **Insert/update policies**:

  * Players: can only insert their own buzz row.
  * Host: can reveal clues, set scores, advance rounds.
* Ensure illegal transitions (e.g. answer before reveal) are blocked by constraints/policies.

---

## State Sync Model

* **Authoritative → DB**: clue reveals, buzz winner, score changes, round advances.
* **Ephemeral → Broadcast**: timers, hover previews, animations.
* **Optimistic UI**: show action locally, then reconcile on DB change.
* **Idempotent updates**: always write with conditions (`is(revealed, false)`).

---

## Production Checklist

* [ ] `VITE_SUPABASE_URL` + `VITE_SUPABASE_ANON_KEY` in Vercel.
* [ ] Supabase Auth URLs include localhost, previews (if needed), and prod.
* [ ] Realtime enabled; subscriptions filtered by `room_id`.
* [ ] RLS enforces room membership + host-only actions.
* [ ] DB ensures first-write-wins for buzzers.
* [ ] No Vercel API routes / SSR touching Supabase.
* [ ] Region chosen close to players (minimize latency).

---

## When to Consider Supabase Edge Functions

* You need **secrets** (third-party APIs).
* You need **transactional multi-step logic** not safe in client.
* You want to **mint custom JWT claims** for RLS.

Always prefer **Supabase Edge Functions** over Vercel functions.

---

## Failure Modes to Test

* Two simultaneous buzzers → DB accepts only one.
* Non-host attempts to reveal → blocked by RLS.
* Player disconnects mid-turn → presence shows offline, host action to forfeit turn.
* Network blip → optimistic UI continues; reconcile state from DB snapshot when back online.

---

## Extensions

* **Latency equalizer**: Host broadcasts official start timestamp; clients sync clocks.
* **Spectator mode**: read-only presence role.
* **Audit log**: append-only table for replay/debug.
* **Preview deploys**: add `https://*.vercel.app` to allowed redirect origins.

---

**Bottom line:**
If it already works on Vite dev server with Supabase Realtime, it will work on Vercel production without touching Vercel functions. Vercel is just a static file host here. All the heavy lifting stays in Supabase.

---

Do you want me to also draft the **core 3–4 RLS policies** (host-only, player-only buzzes, member-only reads) in SQL so your agents have drop-in snippets to check against your existing schema?
