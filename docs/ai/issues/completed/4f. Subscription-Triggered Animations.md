# Issue #4f: Subscription‑Triggered Animations Service (Design Spec)

This document defines a pragmatic, React‑friendly approach to centralizing how animations are defined and triggered from real‑time subscription updates, without centralizing DOM manipulation. The goal is to keep animations robust, testable, and consistent while avoiding brittle global coupling.

## Objectives
- Centralize “when should an animation fire?” decisions derived from real‑time subscription deltas.
- Keep animation execution colocated with the rendered elements (components), ensuring DOM readiness and lifecycle safety.
- Provide a single place to handle cross‑cutting animation concerns (dedupe, timing, completion promises, cleanup).
- Maintain simple, reusable GSAP effects and a thin orchestration layer.

## Current State (Summary)
- GSAP effects registered globally in `src/utils/animations.ts` and initialized in `main.tsx`.
- `AnimationService` (`src/services/animations/AnimationService.ts`) provides promise‑based APIs and timeline tracking for clue reveal, category intro, display transitions, and buzzer state changes.
- Components (e.g., `PlayerDashboard`, `IntegratedBuzzer`) trigger animations using refs and `useEffect`, with some ad‑hoc guards (e.g., polling for DOM readiness, one‑off de‑dup flags).

## Core Design Principles
1) Separation of concerns
- Domain/subscription changes → semantic “animation intents” (pure events, no DOM work)
- Components → execute animations using refs and `AnimationService`
- `AnimationService` → cross‑cutting utilities (dedupe, wait, promises, cleanup) and high‑level sequences

2) React lifecycle alignment
- Components own refs and timing (optionally via `useLayoutEffect` when measuring/setting initial state)
- Service provides helpers to avoid re‑implementing common patterns

3) Minimal, incremental change
- Build on existing GSAP effects and `AnimationService`
- Gradually replace ad‑hoc guards with standardized utilities

## Architecture Overview
- GSAP Effects: Small, reusable effects defined in `src/utils/animations.ts`.
- Animation Service: Orchestrates high‑level sequences and exposes utilities (promises, dedupe, wait, cleanup).
- Animation Events (new): Lightweight pub/sub bus for semantic intents.
- Domain Orchestrator (new): Maps subscription deltas (e.g., game status/focused clue) to animation intents.
- Components: Subscribe to intents relevant to their scope and execute via `AnimationService` when DOM is ready.

## Animation Intents (Examples)
- BoardIntro: `{ gameId, round }` → Animate board appearing at round start
- ClueReveal: `{ clueId }` → Animate clue content reveal in display window
- CategoryIntro: `{ categoryId }` → Animate category intro when needed
- BuzzerPulse (optional): `{ playerId, state }` → Visual feedback on state changes

Intents are semantic; they express “what happened” in game terms. They do not query or manipulate the DOM.

## Domain → Intent Mapping (Orchestrator)
- A single place (e.g., `GameOrchestrator`) subscribed to realtime changes compares previous and next game states and publishes intents:
  - When `status` transitions to `game_intro` → publish `BoardIntro` (round from game)
  - When `focused_clue_id` changes to a non‑null value → publish `ClueReveal`
  - Optional: When categories advance → publish `CategoryIntro`

This provides the requested centralization of “when to trigger” without entangling the animation layer with data access or DOM.

## Component Integration Pattern
- Components subscribe to the Animation Events bus on mount and unsubscribe on unmount.
- When an intent arrives, the component checks its own refs/visibility and calls `AnimationService` methods.
- This ensures the DOM exists and is in the correct state; avoids global selectors; and keeps logic testable.

Example flows (described, no code):
- BoardIntro: Player board container is mounted; on `BoardIntro` intent, component runs `animateDisplayTransition` and then the `animateBoardIn` effect.
- ClueReveal: When the clue content element is mounted and `ClueReveal` intent fires, component calls `animateClueReveal` with the current clue.

## Cross‑Cutting Utilities (in AnimationService)
- Promise‑based methods: All public animation methods return a Promise resolving on completion; callers can await when sequencing matters (e.g., don’t unlock buzzers until intro finishes).
- Dedupe (play‑once): `playOnce(key, fn)` guarantees a sequence runs at most once per logical key (e.g., `boardIntro:<gameId>:<round>`), replacing scattered component flags.
- DOM readiness: `waitForElement(target | selector, timeout)` centralizes DOM polling; prefer refs, but this avoids re‑implementing ad‑hoc waiters when needed.
- Timeline management: Track, clear, pause, and resume active timelines for robust cleanup (already present and retained).

## DOM Readiness and Targeting
- Preferred: Use refs + `useEffect`/`useLayoutEffect` in components; pass the ref element to `AnimationService`.
- If a selector is unavoidable, call `waitForElement` from the service to avoid racing the DOM.
- Favor ref‑scoped queries inside service methods (e.g., query child elements from a passed container) to reduce brittleness.

## Flow Gating: When to Await
- Await when game flow depends on completion (e.g., after BoardIntro before enabling buzzers or inputs).
- Do not await purely decorative animations; avoid introducing unnecessary latency.
- Keep the gating decisions close to the domain logic triggering the action (often the component that owns the UI for that phase).

## Error Handling & Fallbacks
- If an element is not found or the component unmounts mid‑animation:
  - Fail soft (log at debug, skip the remainder) and resolve the promise to avoid deadlocks.
  - Kill timelines in `useEffect` cleanup/unmount via service `clearAllAnimations()` or per‑timeline handles.

## Performance & Accessibility
- Keep effects short (<1s typical) and use easing that preserves readability.
- Avoid animating layout‑thrashing properties where possible; prefer transforms and opacity.
- Respect reduced‑motion preferences (future: global toggle or media query to disable/shorten animations).

## Migration Plan (Incremental)
1. Add `playOnce` and `waitForElement` helpers to `AnimationService`; document key naming conventions.
2. Create `AnimationEvents` bus and a minimal `GameOrchestrator` that publishes `BoardIntro` and `ClueReveal` intents from existing subscriptions.
3. Refactor `PlayerDashboard` to subscribe to intents and use `playOnce` + `waitForElement` instead of ad‑hoc guards; preserve current visuals.
4. Gradually replace global selectors with ref‑scoped queries where feasible.
5. Introduce additional intents (e.g., `CategoryIntro`) only when needed.

## Acceptance Criteria
- Central bus exists and publishes intents from subscription deltas without DOM access.
- Components execute animations via `AnimationService` using refs; DOM readiness race conditions are resolved.
- Dedupe is centralized (no scattered flags); animations play exactly once per intended trigger.
- Promise‑based APIs are used to gate only the flows that require it; no unnecessary blocking.
- No regressions: current animations (board intro, clue reveal, buzzer state) still function as before.

## Risks & Alternatives
- A fully centralized, subscription‑driven service that also manipulates the DOM is brittle in React (selectors, lifecycle). The proposed hybrid avoids this while still centralizing triggers and shared concerns.
- If future needs demand stricter global control, extend the event bus with priorities or per‑intent concurrency rules without changing component contracts.

## Notes
- Keep GSAP effects small and composable; orchestrate sequences in the service.
- Prefer semantic intents over over‑specific triggers; this makes testing and future evolution easier.
- Log succinct debug markers around major sequences to aid triage during live sessions.

## Retained key concerns from original draft
- Subscription‑based triggering: Centralized in a domain→intent orchestrator that publishes semantic Animation Intents (no DOM access in the orchestrator).
- DOM loading: Ensured by component‑owned refs and an optional `waitForElement` helper in AnimationService when selectors are unavoidable.
- Throttling/no repetition: Standardized with `playOnce(key, fn)` to prevent duplicate plays per logical trigger.
- Game resumption/flow gating: Promise‑based AnimationService methods allow awaiting only when game flow truly depends on completion; decorative effects remain non‑blocking.

---

## ✅ COMPLETION STATUS

**Completed**: 2025-01-21
**Status**: ✅ COMPLETE - All requirements met and system production-ready

### Implementation Summary

**All Acceptance Criteria Met**: ✅
- ✅ Central bus exists and publishes intents from subscription deltas without DOM access
- ✅ Components execute animations via AnimationService using refs; DOM readiness resolved
- ✅ Dedupe is centralized (no scattered flags); animations play exactly once
- ✅ Promise‑based APIs used for gating only where needed
- ✅ No regressions: all current animations function correctly

**Files Implemented**:
- `src/services/animations/AnimationDefinitions.ts` - All 6 GSAP animations
- `src/services/animations/AnimationOrchestrator.ts` - Subscription → intent mapping
- `src/services/animations/AnimationEvents.ts` - Pub/sub bus with recent intent caching
- `src/services/animations/AnimationService.ts` - Orchestration utilities (playOnce, waitForElement)
- `src/services/animations/ClueDisplayService.ts` - Content population
- `src/components/players/PlayerDashboard.tsx` - Animation subscriptions and cleanup
- `src/components/players/PlayerPodiums.tsx` - CSS transition integration
- `docs/ai/reference/ANIMATION_DEFINITION_GUIDE.md` - Complete system documentation

**Additional Improvements Beyond Spec**:
- ✅ Host-driven triggers (animations fire on host button clicks)
- ✅ CSS-first design (final states in CSS, JavaScript only animates)
- ✅ CSS transitions for simple effects (buzz-in)
- ✅ Proper positioning (animations start from focused cell)
- ✅ No content flash (elements hidden before population)
- ✅ Complete cleanup (display window clears on clue completion)
- ✅ Comprehensive documentation with troubleshooting guide